-- This file was generated by				
-- Qfsm Version 0.54					
-- (C) Stefan Duffner, Rainer Strobel			


-- Inputs:   a
-- State/Output x y
-- S0           0 0 
-- S1           0 0 
-- S2           0 0 
-- S3           0 0 
-- S4           1 1 
-- S5           0 0 
-- S6           0 0 
-- S7           0 0 
-- S8           0 0 
-- S9           0 0 
-- S10          1 0 

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;

ENTITY FSM IS
  PORT (clk: IN std_ulogic;
        rst_n: IN std_ulogic;
        a: IN std_ulogic;
        x: OUT std_ulogic;
        y: OUT std_ulogic;
        debug_state: OUT std_ulogic_vector (3 DOWNTO 0));
END FSM;

ARCHITECTURE behave OF FSM IS

TYPE state_type IS (S0, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10);
SIGNAL next_state, current_state : state_type;

BEGIN
  state_register: PROCESS (rst_n, clk)
  BEGIN
    IF rst_n='0' THEN
      current_state <= S0;
    ELSIF rising_edge(clk) THEN
      current_state <= next_state;
    END IF;
  END PROCESS;

  next_state_and_output_logic: PROCESS (current_state, a)
    VARIABLE temp_input : std_ulogic_vector(0 DOWNTO 0);
    VARIABLE temp_output : std_ulogic_vector(5 DOWNTO 0);
  BEGIN
    temp_input(0) := a;
    CASE current_state IS
      WHEN S0 => temp_output := "010100";
        IF temp_input="0" THEN
          next_state <= S1;
        ELSIF temp_input="1" THEN
          next_state <= S5;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN S1 => temp_output := "101100";
          next_state <= S2;
      WHEN S2 => temp_output := "000000";
          next_state <= S3;
      WHEN S3 => temp_output := "001100";
          next_state <= S4;
      WHEN S4 => temp_output := "010011";
        IF temp_input="1" THEN
          next_state <= S5;
        ELSIF temp_input="0" THEN
          next_state <= S1;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN S5 => temp_output := "000100";
        IF temp_input="0" THEN
          next_state <= S6;
        ELSIF temp_input="1" THEN
          next_state <= S8;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN S6 => temp_output := "011000";
        IF temp_input="0" THEN
          next_state <= S7;
        ELSIF temp_input="1" THEN
          next_state <= S9;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN S7 => temp_output := "011100";
          next_state <= S4;
      WHEN S8 => temp_output := "100000";
          next_state <= S9;
      WHEN S9 => temp_output := "100100";
          next_state <= S10;
      WHEN S10 => temp_output := "101010";
        IF temp_input="0" THEN
          next_state <= S1;
        ELSIF temp_input="1" THEN
          next_state <= S5;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN OTHERS => temp_output := (OTHERS =>'X');
      next_state <= S0;
    END CASE;
    x <= temp_output(1);
    y <= temp_output(0);
    debug_state <= temp_output (5 DOWNTO 2);
  END PROCESS;

END behave;
